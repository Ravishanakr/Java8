=================
Java 1.8v Features
=================

Java 1.0

Java 1.1

Java 1.2   (Collection Framework)

..

Java 1.5  (Big Release)

..

Java 1.8 (Big Release) ------- Functional Programming

..

Java 19 


=================
Java 1.8v Features
=================

-> Java 1.8v introduced lot of new features in java 

-> Java 1.8v new features changed java programming style

=========================
Main Objectivies of Java 1.8v
=========================

-> Simplify Java Programming

-> Enable Functional Programming

-> Write more readable and consice code


=================
 Java 1.8 Features
=================

1) Interface changes

		1.1 ) Default Methods
		1.2 ) Static Methods

2)  Functional Interfaces (@FunctionalInterface)

		2.1 ) Predicate & BiPredicate
		2.2 ) Consumer  & BiConsumer
		2.3 ) Supplier
		2.4 ) Function & BiFunction

3) Lambda Expressions

4) Method References & Constructor References

5) ******  Stream API  ********

6) Optional class (to avoid null pointer exceptions)

7) Spliterator

8) StringJoiner

9) forEach ( ) method

10) Date & Time API

11) Nashron Engine

12) I/O Stream Changes (Files.lines(Path p))

13) Base64 Encoding & Decoding


================
Interface changes
================

-> Interface means collection of abstract methods

Note: The method which doesn't contain body is called as abstract method

->  class can implement interface using "implements"

-> When a class is implementing interface its mandatory that class should 
  implement all abstract methods of that interface othewise class can't be compile.

=> Here i am taking one interface with one abstract method. All the classes which 
   are implementing that interface should overide interface method(s).


interface Vehicle {

	public abstract void startVechicle ( );
}

class Car implements Vehicle {

	public void startVehicle ( ) {
		// logic to start car
	}
}

class Bus implements Vehicle {
	public void startVehicle ( ) {
		// logic to start  bus
	}
}

class Bike implements Vehicle {
	public void startVehicle ( ) {
		// logic to start  bike
	}
}

=> If we add new method in interface then Car, Bike and Bus will fail at compile time.

=> To overcome above problem we will use Default & Static methods



1) Interface can have concreate methods from 1.8v

2) Interface concrete method should be default or static

3) interface default methods we can override in impl classes

4) interface static methods we can't overide in impl classes

5) We can write multiple default & static methods in interface

6) Default & Static method introduced to provide backward compatability

7) Backward compatibility is adding new features without breaking the old code

8) Interface will allow us to write Static methods,so we no need to write
    utility methods by creating a class.

Ex:  forEach ( ) method added in java.util.Iterable interface





=====================
Lambda Expressions
====================

->Lambda is an anonymous function.
->Reduce boilerplate code.
->especially when dealing with functional interfaces
->This makes code shorter, cleaner, and easier to understand by focusing on the core logic

-> Java is called as Object Oriented Programming language. 
   Everything will be represented using Classes and Objects.

-> From 1.8v onwards Java is also called as Functional Programming Language.
  
-> Lambda correspondences to an interface and specifically abstract methods present in interface
		 
-> when ever you write lambda that interface should have only 1 abstract method and any no. of default    and static methods.
		 	
-> Lambda enables Functional Programming - What is Functional Programming ?
   Till now in Java we passed data as method argument. Passing the functionality
   as method argument is called as Functional programming.
   
-> Why we need to annotate @FunctionalInterface over top of Interface?
==>beacuase there may be a chance that any other devloper can write another abstract method() with same signature,so when we create lamda the compiler will get ambiguity problem.    
   
-> @FunctionalInterface is an interface in which we can write only one abstract
    method and any no. of default and static methods.
		
   
==============
What is Lambda
==============

-> Lambda is an anonymous function

		- No Name
		- No Modifier
		- No Return Type

Ex:-1

public void m1 ( ) {
	s.o.p("hi");
}


 ( ) -> { s.o.p ("hi") }

Note: When we have single line in body then curly braces are optional

 ( ) -> s.o.p ("hi");

Ex:-2

public void add (int a, int b){
	s.o.p(a+b);
}

( int a, int b)  -> { s.o.p (a+b) } ;

		(or)

(int a, int b) -> s.o.p (a+b);

		(or)

Lambda Expression : (a, b) -> s.o.p(a+b);


Ex:-3

public int getLength (String name) {
	return name.length ( );
}

(String name) -> { return name.length ( ) };

(String name) -> return name.length ( ) ;

(name) -> return name.length ( );

Lambda Expression : name -> name.length ( ) ;


Ex:-4

public Double getEmpSalary (Employee emp) {

	return emp.getSalary ( );

}

Lambda Expression : emp -> emp.getSalary ( );


==================
Functional Interfaces
==================

-> The interface which contains only one abstract method and and any no. of default and static methods
   is called as Functional Interface

-> Functional Interfaces are used to invoke Lambda expressions

-> Below are some predefined functional interfaces

			Runnable ------------> run ( ) method

			Callable ----------> call ( ) method

			Comparable -------> compareTo ( )

-> To represent one interface as Functional Interface we will use @FunctionalInterface annotation.


@FunctionalInterface
public interface MyInterface {
	public void m1( );
}

Note: When we write @FunctionalInterface then our compiler will check 
      interface contains only one abstract method or not.


-> In Java 8 several predefined Functional interfaces got introduced they are

	1) Predicate(test) & BiPredicate    -->takes one argument and return boolean
	2) Consumer(accept) & BiConsumer    -->take one argument and return nothing
    3) Function(apply) & BiFunction     -->Take one one argument return Some another argument
	3) Supplier(get)                    -->Supplier takes nothing and return something      
 

-> The above interfaces are provided in java.util.function package


========
Predicate
========

-> It is predefined Functional interface

-> It is used check condition and returns true or false value

-> Predicate interface having only one abstract method that is test (T t)


			interface Predicate{
				boolean test(T t);
			}		


// Predicate Example

package in.ashokit.java8;

import java.util.function.Predicate;

public class PredicateDemo {

	public static void main(String[] args) {

		Predicate<Integer> p = i -> i > 10;
		System.out.println(p.test(5));
		System.out.println(p.test(15));
	}

}

=======================================================================================
Task: Declare names in an array and print names which are starting with 'A' using lambda expression.

		String[ ]  names = {"Anushka", "Anupama", "Deepika", "Kajol", "Sunny" };

=========================================================================================

package in.ashokit.java8;

import java.util.function.Predicate;

public class PredicateDemo2 {

	public static void main(String[] args) {

		String[ ] names = { "Anushka", "Anupama", "Deepika", "Kajol", "Sunny" };

		Predicate<String> p = name -> name.charAt(0) == 'A';

		for (String name : names) {
			if ( p.test(name) ) {
				System.out.println(name);
			}
		}
	}
}

============================================================================
Task-2 : Take list of persons and print persons whose age is >= 18 using Lambda Expression
============================================================================

package in.ashokit.java8;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

class Person {

	String name;
	int age;

	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
}

public class PredicatePersonsDemo {

	public static void main(String[] args) {

		Person p1 = new Person("John", 26);
		Person p2 = new Person("Smith", 16);
		Person p3 = new Person("Raja", 36);
		Person p4 = new Person("Rani", 6);

		List<Person> persons = Arrays.asList(p1, p2, p3, p4);

		Predicate<Person> predicate = p -> p.age >= 18;

		for (Person person : persons) {
			if (predicate.test(person)) {
				System.out.println(person.name);
			}
		}
	}
}

================
Predicate Joining
===============

-> To combine multiple predicates we will use Predicate Joining

and ( ) method

or ( ) method

Task-1 : Print emp names who are working in Hyd location in DB team.

package in.ashokit.java8;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

class Employee {

	String name;
	String location;
	String dept;

	Employee(String name, String location, String dept) {
		this.name = name;
		this.location = location;
		this.dept = dept;
	}
}

public class PredicateJoinDemo {

	public static void main(String[] args) {
		Employee e1 = new Employee("Anil", "Chennai", "DevOps");
		Employee e2 = new Employee("Rani", "Pune", "Networking");
		Employee e3 = new Employee("Ashok", "Hyd", "DB");
		Employee e4 = new Employee("Ganesh", "Hyd", "DB");

		List<Employee> emps = Arrays.asList(e1, e2, e3, e4);

		Predicate<Employee> p1 = (e) -> e.location.equals("Hyd");
		Predicate<Employee> p2 = (e) -> e.dept.equals("DB");
		Predicate<Employee> p3 = (e) -> e.name.startsWith("A");

		// Predicate Joining
		Predicate<Employee> p = p1.and(p2).and(p3);

		for (Employee e : emps) {
			if (p.test(e)) {
				System.out.println(e.name);
			}
		}
	}
}

==========================
Supplier Functional Interface
==========================

-> Supplier is a predefined functional interface introduced in java 1.8v

-> It contains only one abstract method that is get ( ) method

-> Supplier interface will not take any input, it will only returns the value.

Ex:
----

OTP Generation



package in.ashokit.java8;

import java.util.function.Supplier;

public class SupplierDemo {

	public static void main(String[] args) {

		Supplier<String> s = () -> {
			String otp = "";
			for (int i = 1; i <= 6; i++) {
				otp = otp + (int) (Math.random() * 10);
			}
			return otp;
		};

		System.out.println(s.get());
		System.out.println(s.get());
		System.out.println(s.get());
		System.out.println(s.get());
		System.out.println(s.get());
		System.out.println(s.get());
	}
}

==========================
Consumer Functional Interface
==========================

-> Consumer is predefined functional interface

-> It contains one abstract method i.e accept (T t)

-> Consumer will accept input but it won't return anything

Note: in java 8 forEach ( ) method got introduced. forEach(Consumer consumer) method will take Consumer as parameter.


package in.ashokit.java8;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class ConsumerDemo {

	public static void main(String[] args) {

		Consumer<String> c = (name) -> System.out.println(name + ", Good Evening");

		c.accept("Ashok");
		c.accept("John");
		c.accept("Rani");

		List<Integer> numbers = Arrays.asList(10, 20, 30, 40);
		// for loop
		// for each loop
		// iterator
		// list iterator
		
		numbers.forEach(i -> System.out.println(i));
	}
}


=========================================================
Retrieve student record based on student id and return that record
=========================================================


Predicate ------> takes inputs ----> returns true or false    ===>    test ( )

Supplier -----> will not take any input---> returns output  ===> get ( )

Consumer ----> will take input ----> will not return anything  ===> accept ( )

Function -----> will take input ---> will return output ===> apply ( )


=========================
Function Functional Interface
=========================

-> Function is predefined functional interface

-> Funcation interface having one abstract method i.e apply(T r)

		interface Function<R,T>{
			R apply (T t);
		}	

-> It takes input and it returns output



package in.ashokit.java8;

import java.util.function.Function;

public class FunctionDemo {

	public static void main(String[] args) {

		Function<String, Integer> f = (name) -> name.length();

		System.out.println(f.apply("ashokit"));
		System.out.println(f.apply("hyd"));
		System.out.println(f.apply("sachin"));

	}
}

=========================================================
Task : Take 2 inputs and perform sum of two inputs and return ouput
=========================================================


BiFunction<Integer,Integer,Integer> bif = (a,b) -> a+b;

Integer sum = bi.apply(10,20);


================
Method References
=================

-> Used to create simple lambda expressions by referencing existing methods.
-> Method reference is used to refer method of functional interface


There are 3 kinds of method references:

 1)Reference to a static method
 2)Reference to an instance method
 3)Reference to a constructor

package in.ashokit.java8;

@FunctionalInterface
interface MyInterface {
	public void m1();
}

public class MethodRef {

	public static void m2() {
		System.out.println("This is m2( ) method");
	}

	public static void main(String[] args) {
		MyInterface mi = MethodRef::m2;
		mi.m1();
	}
}


package in.ashokit.java8;

public class InstanceMethodRef {

	public void m1() {
		for (int i = 1; i <= 5; i++) {
			System.out.println(i);
		}
	}

	public static void main(String[] args) {

		InstanceMethodRef im = new InstanceMethodRef();

		Runnable r = im::m1;
		Thread t = new Thread(r);

		t.start();
	}
}



public class Test {

	public static void main(String[] args) {

		// Doctor d = new Doctor();

		Supplier<Doctor> s = Doctor::new;
		Doctor doctor = s.get();
		System.out.println(doctor.hashCode());

	}

}

class Doctor {

	public Doctor() {
		System.out.println("Doctor constructor....");
	}
}


===========================================================================
Task : WAJP to print numbers from 1 to 5 using Thread with the help of Runnable interface
============================================================================


//Approach-1
public class ThreadDemo1 implements Runnable {

	@Override
	public void run() {
		for (int i = 1; i <= 5; i++) {
			System.out.println(i);
		}
	}

	public static void main(String[] args) {
		ThreadDemo1 td = new ThreadDemo1();
		Thread t = new Thread(td);
		t.start();
	}
}


package in.ashokit.java8;

// Approach-2
public class ThreadDemo2 {

	public static void main(String[] args) {

		Runnable r = new Runnable() {
			@Override
			public void run() {
				for (int i = 1; i <= 5; i++) {
					System.out.println(i);
				}
			}
		};

		Thread t = new Thread(r);
		t.start();
	}
}

// Approach - 3 using Lambda Expression
package in.ashokit.java8;

public class ThreadDemo3 {

	public static void main(String[] args) {

		Runnable r = () -> {
			for (int i = 1; i <= 5; i++) {
				System.out.println(i);
			}
		};

		Thread t = new Thread(r);
		t.start();
	}
}


==================================================================
Task: WAJP to store numbers in ArrayList and sort numbers in desending order 
==================================================================


// Approach-1 ( without Lambda)

package in.ashokit.java8;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class NumbersSort1 {

	public static void main(String[] args) {

		ArrayList<Integer> al = new ArrayList<>();
		al.add(5);
		al.add(3);
		al.add(4);
		al.add(1);
		al.add(2);

		System.out.println("Before Sort :: " + al);

		Collections.sort(al, new NumberComparator());

		System.out.println("After Sort :: " + al);
	}

}

class NumberComparator implements Comparator<Integer> {
	@Override
	public int compare(Integer i, Integer j) {
		if (i > j) {
			return -1;
		} else if (i < j) {
			return 1;
		}
		return 0;
	}
}


// Approach-2 ( with Lambda)

package in.ashokit.java8;

import java.util.ArrayList;
import java.util.Collections;

public class NumbersSort1 {

	public static void main(String[] args) {

		ArrayList<Integer> al = new ArrayList<>();
		al.add(5);
		al.add(3);
		al.add(4);
		al.add(1);
		al.add(2);

		System.out.println("Before Sort :: " + al);

		Collections.sort(al, (i, j) -> (i > j) ? -1 : 1);

		System.out.println("After Sort :: " + al);
	}
}

==========================
forEach (Consumer c) method
===========================

-> forEach (Consumer c) method introduced in java 1.8v

-> forEach ( ) method added in Iterable interface

-> forEach ( ) method is a default method (it is having body)

-> This is method is used to access each element of the collection (traverse collection from start to end)


package in.ashokit.java8;

import java.util.ArrayList;

public class NumbersSort1 {

	public static void main(String[] args) {

		ArrayList<Integer> al = new ArrayList<>();
		al.add(5);
		al.add(3);
		al.add(4);
		al.add(1);
		al.add(2);

		al.forEach(i -> System.out.println(i));
	}
}

==============
StringJoiner
==============

-> java.util.StringJoiner class introduced in java 1.8v

-> It is used to construct a sequence of characters separated by a delimiter.

-> We can concat prefix and suffix while joininging strings using StringJoiner


		StringJoiner sj = new StringJoiner (CharSequence delim);
		StringJoiner sj = new StringJoiner (CharSequence delim, CharSequence prefix, CharSequence suffix);




package in.ashokit.java8;

import java.util.StringJoiner;

public class StringJoinerDemo {

	public static void main(String[] args) {

		StringJoiner sj1 = new StringJoiner("-");
		sj1.add("ashok");
		sj1.add("it");
		sj1.add("java");
		System.out.println(sj1); // ashok-it-java

		StringJoiner sj2 = new StringJoiner("-", "(", ")");
		sj2.add("ashok");
		sj2.add("it");
		sj2.add("java");
		System.out.println(sj2); // (ashok-it-java)

	}

}



=============
Optional Class
=============

-> java.util.Optional class introduced in java 1.8v

-> Optional class is used to avoid NullPointerExceptions in the program


Q) What is NullPointerException (NPE) ?

Ans) When we perform some operation on null value then we will get NullPointerException


				String s = null;

				s.length ( ) ;  // NPE


-> To avoid NullPointerExceptions we have to implement null check before performing operation on the Object like below.

				String s = null;

				if( s! = null ) {
					System.out.println(s.length ( ));
				}



Note: In project there is no gaurantee that every programmer will implement null checks. 
    If any body forgot to implement null check then program will throw NullPointerException.

-> To avoid this problem we are using optional class below so that that method will 
   return optional class then programmer must and should implement null check


package in.ashokit.java8;

import java.util.Optional;

public class User {


	// Without Optional object
	public String getUsernameById(Integer id) {
		if (id == 100) {
			return "Raju";
		} else if (id == 101) {
			return "Rani";
		} else if (id == 102) {
			return "John";
		} else {
			return null;
		}
	}

	// with Optional Object
	public Optional<String> getUsername(Integer id) {
		String name = null;
		if (id == 100) {
			name = "Raju";
		} else if (id == 101) {
			name = "Rani";
		} else if (id == 102) {
			name = "John";
		}
		return Optional.ofNullable(name);
	}
}


package in.ashokit.java8;

import java.util.Optional;
import java.util.Scanner;

public class MsgService {

	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);

		System.out.println("Enter User ID");
		int userId = s.nextInt();

		User u = new User();
		/*String userName = u.getUsernameById(userId);
		String msg = userName.toUpperCase() + ", Hello"; 
		System.out.println(msg);*/
		
		Optional<String> username = u.getUsername(userId);
		
		if(username.isPresent()) {
			String name = username.get();
			System.out.println(name.toUpperCase()+", Hello");
		}else {
			System.out.println("No Data Found");
		}
	}
}


Optional.ofNullable-->if we pass null or value it will return optional
Optional.of()-->if pass null value then it throws Null pointer expection
get()-->if the value/object present then will print other wis throw NoSuhElemntException



=======================
Date & Time API Changes
=======================

-> In java we have below 2 classes to represent Date

			1) java.util.Date 

			2) java.sql.Date


Note: When we are performing database operations then we will use java.sql.Date class.

-> For normal Date related operations we will use java.util.Date class

			Date d = new Date ( );
			System.out.prinln(d);

Note: When we create Object for Date class, it will represent both date and time.

-> If we want to get only date or only time then we need to format it using SimpleDateFormat class.


========================
java.text.SimpleDateFormat
=======================

-> SimpleDateFormat is a predefined class in java.text pacakage

-> This class provided methods to perform Date conversions


		Date to String conversion  ===>   String format (Date d) 

		String to Date conversion ===>  Date parse(String str)


// Date Conversions Example

package in.ashokit.java8;

import java.text.SimpleDateFormat;
import java.util.Date;

public class DateDemo {

	public static void main(String[] args) throws Exception {

		Date date = new Date();
		System.out.println(date);

		// Converting Date to String
		SimpleDateFormat sdf1 = new SimpleDateFormat("dd/MM/yyyy");
		String format1 = sdf1.format(date);
		System.out.println(format1);

		SimpleDateFormat sdf2 = new SimpleDateFormat("MM/dd/yyyy");
		String format2 = sdf2.format(date);
		System.out.println(format2);

		// Convert String to Date
		SimpleDateFormat sdf3 = new SimpleDateFormat("yyyy-MM-dd");
		Date parsedDate = sdf3.parse("2022-12-20");
		System.out.println(parsedDate);
		
	}
}

=========================================================================================

=> To overcome the problems of java.util.Date class java 1.8 introduced Date API changes

=> In java 1.8 version, new classes got introduced to deal with Date & Time functionalities

				1) java.time.LocalDate  (it will deal with only date)

				2) java.time.LocalTime  (it will deal with only time)

				3) java.time.LocalDateTime (it will deal with both date & time)



// Java 1.8 Date API Example

package in.ashokit.java8;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Period;

public class NewDateDemo {

	public static void main(String[] args) {

		LocalDate of = LocalDate.of(2021, 1, 20);
		System.out.println(of);

		LocalDate date = LocalDate.now();
		System.out.println(date);

		date = date.plusDays(3);
		System.out.println(date);

		date = date.plusMonths(1);
		System.out.println(date);

		date = date.plusYears(2);
		System.out.println(date);

		boolean leapYear = LocalDate.parse("2020-12-22").isLeapYear();
		System.out.println("Leap Year :: " + leapYear);

		boolean before = LocalDate.parse("2021-12-22").isBefore(LocalDate.parse("2022-12-22"));
		System.out.println("Before Date : " + before);

		LocalTime time = LocalTime.now();
		System.out.println(time);
		time = time.plusHours(2);
		System.out.println(time);

		LocalDateTime datetime = LocalDateTime.now();
		System.out.println(datetime);

		Period period = Period.between(LocalDate.parse("1991-05-20"), LocalDate.now());
		System.out.println(period);

		Duration duration = Duration.between(LocalTime.parse("18:00"), LocalTime.now());
		System.out.println(duration);
	}
}



=================

1) What are new changes in java 8 version

2) Interface Changes

		2.1 ) Default Methods
		2.2 ) Static Methods

3) Why Default & Static method introduced in java 8

4) Lambda Expressions Introduction

5) How to write Lambda Expression

6) How to invoke lambda expression

7) Functional Interfaces

		7.1) Predicate & BiPredicate
		7.2) Supplier
		7.3) Consumer & BiConsumer
		7.4) Function & BiFunction

8) Collections Sorting using Lambda

9) Thread Creation Using Lambda

10) Method References & Constructor References

11) java.util.StringJoiner class

12) java.utils.Optional class

13) forEach ( Consumer c ) method 

14) Date & Time API Changes

			14.1) LocalDate
			14.2) LocalTime
			14.3) LocalDateTime
			14.4) Period
			14.5) Duration

===========
Stream API
===========

->Stream is an interface introduced in Java8 under package called java.util package
  and it will reperest sequence of elements and supports parlell and aggregation process.
  
->Using streams we can perform operations on Collection or arrays.

->Streams work perfectly with lambdas.


===============================
Few Important Points About Streams
===============================

1) Stream is not a data structure. Stream means bunch of operations applied on source data. 
   Source can be collection or array.

2) Stream will not change original data structure of the source (It will just process the data given by the source.)


===============
Stream Creation
===============

-> In Java we can create Stream in 2 ways

			1) Stream.of (e1, e2, e3, e4.....)

			2) stream ( )  method



// Java Program to Create Stream

package in.ashokit.streams;

import java.util.ArrayList;
import java.util.stream.Stream;

public class FirstDemo {

	public static void main(String[] args) {

		// Approach-1
		Stream<Integer> stream1 = Stream.of(1, 2, 3, 4, 5);

		ArrayList<String> names = new ArrayList<>();
		names.add("John");
		names.add("Robert");
		names.add("Orlen");

		// Approach-2
		Stream<String> stream2 = names.stream();

	}
}

===================
Stream Operations
===================

-> Stream API provided several methods to perform Operations on the data

-> We can divide Stream api methods into 2 types

			1) Intermediate Operational Methods

			2) Terminal Operational Methods


-> Intermediate Operational methods will perform operations on the stream and returns a new Stream

-> Since they are lazy, intermediate operations do not get executed until a terminal operation is invoked.   
  
->multiple intermediate operations can be chained together.

EX;
	sorted() ->comparator        filter() -> predicate 
    distinct() ->Function 	     map()-> -> Function
    flatMap()->Function          limit() 	
								 skip()
								 peek()-->1)it is an intermediate operation which will take Consumer as a argument
								 2)It is primarily used for debugging or logging purposes.
								 
-> Terminal operations are used to consume the Stream and produce a result.such as a value, 
   or collection.

					Ex: 
					 ->collect,count,reduce(),forEach(),forEachOrdered()
					 ->min()(comparator) ,max()(comparator)
					 ->anyMatch() (predicate) ,allMatch() (predicate),noneMatch() (predicate)
					 ->findAny(),findFirst()


=====================
Filtering with Streams
======================

-> Filtering means getting required data from original data

		Ex: get only even numbers from given numbers

		Ex:  get emps whose salary is >= 1,00,000

		Ex:  Get Mobiles whose price is <= 15,000


-> To apply filter on the data, Stream api provided filter ( ) method

		Ex :  Stream   filter (Predicate p)


===================
Example - 1 : Filter
==================


package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;

public class FirstDemo {

	public static void main(String[] args) {

		List<Integer> list = Arrays.asList(66, 32, 45, 12, 20);

		/*for (Integer i : list) {
			if (i > 20) {
				System.out.println(i);
			}
		}*/
		
		/*Stream<Integer> stream = list.stream();
		
		Stream<Integer> filteredStrem = stream.filter(i -> i > 20);
		
		filteredStrem.forEach(i -> System.out.println(i));*/
		
		list.stream().filter(i -> i > 20).forEach(i -> System.out.println(i));
		
	}
}


==========================
Example - 2 : Filter
========================

package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;

public class FirstDemo {

	public static void main(String[] args) {

		List<String> names = Arrays.asList("John", "Anushka", "Anupama", "Smith", "Ashok");
		
		names.stream().filter(i -> i.startsWith("A")).forEach(i -> System.out.println(i));
		
	}
}

==================
Example - 3 : Filter
==================

package in.ashokit.streams;

import java.util.stream.Stream;

public class FirstDemo {

	public static void main(String[] args) {

		User u1 = new User("Anushka", 25);
		User u2 = new User("Smith", 30);
		User u3 = new User("Raju", 15);
		User u4 = new User("Rani", 10);
		User u5 = new User("Charles", 35);
		User u6 = new User("Ashok", 30);

		Stream<User> stream = Stream.of(u1, u2, u3, u4, u5, u6);
		
		// stream.filter(u -> u.age >= 18).forEach(u -> System.out.println(u));
		
			/*stream.filter(u -> u.age >= 18 && u.name.startsWith("A"))
				  .forEach(u -> System.out.println(u));*/
		
		stream.filter(u -> u.age >= 18)
			    .filter(u -> u.name.startsWith("A"))
			    .forEach(u -> System.out.println(u));

	}
}

class User {

	String name;
	int age;

	User(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String toString() {
		return "User [name=" + name + ", age=" + age + "]";
	}
}


===================
Mapping Operations
===================

-> Mapping operations are belongs to intermediate operations in the Stream api
-> map is used for transforming the elements same type or another type
-> map is method which takes Function as a parameter
	
		Ex : Stream  map (Function function) ;



=======================
Example-1 : map ( ) method
=======================

public class FirstDemo {

	public static void main(String[] args) {
		
		
		List<String> names = Arrays.asList("india","usa","uk", "japan");
		
		/*for(String name : names) {
			System.out.println(name.toUpperCase());
		}*/
		
		names.stream().map(name -> name.toUpperCase()).forEach(n -> System.out.println(n));

		names.stream().mapToInt(name -> name.length()).forEach(i -> System.out.println(i));
		
	}
}

=========================
Example-2 : map ( ) method
========================

public class FirstDemo {

	public static void main(String[] args) {
		
		
		List<String> names = Arrays.asList("Ashok", "Anil", "Raju", "Rani", "John", "Akash", "Charles");
		
		// print name with its length which are starting with 'A' using Stream API
						//Ashok - 5
						//Anil  - 4
						//Akash - 5
		
		names.stream()
			 .filter(name -> name.startsWith("A"))
			 .map(name -> name + "-" +name.length())
			 .forEach(name -> System.out.println(name));
	}
}


=======================
Example-3 : map ( ) method
========================

class Employee ( ) {

	String name;
	int age;
	double salary;

}

Task : Print Emp Name with Emp age whose salary is >= 50,000 using Stream API.


public class FirstDemo {

	public static void main(String[] args) {

		Employee e1 = new Employee("John", 35, 55000.00);
		Employee e2 = new Employee("David", 25, 45000.00);
		Employee e3 = new Employee("Buttler", 35, 35000.00);
		Employee e4 = new Employee("Steve", 45, 65000.00);
		
		Stream<Employee> stream = Stream.of(e1, e2, e3, e4);
		
		/*stream.filter(e -> e.salary >= 50000.00)
			  .map(e -> e.name+" - " +e.age)
			  .forEach(e -> System.out.println(e));*/
		
		stream.filter(e -> e.salary >= 50000.00)
		  .forEach(e -> System.out.println(e.name + "-" + e.age));

	}
}

class Employee {

	String name;
	int age;
	double salary;

	public Employee(String name, int age, double salary) {
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
}

===================================
Q) What is flatMap(Function f) method ?
===================================

-> It is used to flaten list of streams into single stream
-> used when we dealing with nested collections



public class FirstDemo {

	public static void main(String[] args) {

		List<String> javacourses = Arrays.asList("core java", "adv java", "springboot");

		List<String> uicourses = Arrays.asList("html", "css", "bs", "js");

		List<List<String>> courses = Arrays.asList(javacourses, uicourses);
		
		//courses.stream().forEach(c -> System.out.println(c));
		
		Stream<String> fms = courses.stream().flatMap(s -> s.stream());
		
		fms.forEach(c -> System.out.println(c));

	}
}

==========================
Slicing Operations with Stream
==========================

1) distinct ( )  => To get unique elements from the Stream

2) limit ( long maxSize )  => It will return the first n elements from stream

3) skip (long n)  => skip the first n elements and return the rest stream


Note: All the above 3 methods are comes under Intermediate Operational Methods. They will perform operation and returns new Stream.

package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;

public class FirstDemo {

	public static void main(String[] args) {

		List<String> javacourses = Arrays.asList("corejava", "advjava", "springboot", "restapi", "microservices");

		javacourses.stream().limit(3).forEach(c -> System.out.println(c));

		javacourses.stream().skip(3).forEach(c -> System.out.println(c));

		List<String> names = Arrays.asList("raja", "rani", "raja", "rani", "guru");
		names.stream().distinct().forEach(name -> System.out.println(name));

	}
}


============================
Matching Operations with Stream
============================

1)  boolean anyMatch (Predicate p )
2)  boolean allMatch (Predicate p )
3)  boolean noneMatch (Predicate p )

Note: The above 3 methods are belongs to Terminal Operations because they will do operation and they will return result directley (they won't return stream)

-> The above methods are used to check the given condition and returns true or false value based on condition.


package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;

public class FirstDemo {

	public static void main(String[] args) {

		Person p1 = new Person("John", "USA");
		Person p2 = new Person("Steve", "JAPAN");
		Person p3 = new Person("Ashok", "INDIA");
		Person p4 = new Person("Ching", "CHINA");

		List<Person> persons = Arrays.asList(p1, p2, p3, p4);

		boolean status1 = persons.stream().anyMatch(p -> p.country.equals("INDIA"));
		System.out.println("Any Indian Available ? :: " + status1);

		boolean status2 = persons.stream().anyMatch(p -> p.country.equals("CANADA"));
		System.out.println("Any Canadian Available ? :: " + status2);

		boolean status3 = persons.stream().allMatch(p -> p.country.equals("INDIA"));
		System.out.println("All Persons from India ? :: " + status3);

		boolean status4 = persons.stream().noneMatch(p -> p.country.equals("MEXICO"));
		System.out.println("No Persons from Mexico ? :: " + status4);

	}
}

class Person {

	String name;
	String country;

	public Person(String name, String country) {
		this.name = name;
		this.country = country;
	}

}

===================
Collectors with Stream
==================

-> Collectors are used to collect data from Stream

		
===================
Example-1 : Collectors
===================

package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class FirstDemo {

	public static void main(String[] args) {

		Person p1 = new Person("John", "USA");
		Person p2 = new Person("Steve", "JAPAN");
		Person p3 = new Person("Ashok", "INDIA");
		Person p4 = new Person("Ching", "CHINA");
		Person p5 = new Person("Kumar", "INDIA");

		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		List<Person> indians = persons.stream()
									  .filter(p -> p.country.equals("INDIA"))
									  .collect(Collectors.toList());
		
		indians.forEach(i -> System.out.println(i));

	}
}

class Person {

	String name;
	String country;

	public Person(String name, String country) {
		this.name = name;
		this.country = country;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", country=" + country + "]";
	}

}

===================
Example-2: Collectors
===================

package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class FirstDemo {

	public static void main(String[] args) {

		Person p1 = new Person("John", "USA");
		Person p2 = new Person("Steve", "JAPAN");
		Person p3 = new Person("Ashok", "INDIA");
		Person p4 = new Person("Ching", "CHINA");
		Person p5 = new Person("Kumar", "INDIA");

		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		// collect names of persons who are belongs to india and store into names collection
		
		List<String> names = persons.stream()
									.filter(p -> p.country.equals("INDIA"))
									.map(p -> p.name)
									.collect(Collectors.toList());
		System.out.println(names);
	}
}

class Person {

	String name;
	String country;

	public Person(String name, String country) {
		this.name = name;
		this.country = country;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", country=" + country + "]";
	}

}


==============================================
Set - 1 : Intermediate Operations   (will return Stream)
==============================================

Filters ----> filter ( ) 

Mappings ----> map  ( ) & flatMap ( )

Slicing      ----> distinct ( ) & limit ()  & skip ( )


==============================================
Set - 2 : Terminal Operations  (will return result)
==============================================

Finding   ---> findFirst ( ) & findAny ( )

Matching  ---> anyMatch ( ) & allMatch ( ) & noneMatch ( )

Collecting  ---> collect ( )







============
Requirement
===========

=> Write a java program to get MAX, MIN and AVG salary from given employees data using Stream API.



package in.ashokit.streams;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class FirstDemo {

	public static void main(String[] args) {

		Employee e1 = new Employee(1, "Robert", 26500.00);
		Employee e2 = new Employee(2, "Abraham", 46500.00);
		Employee e3 = new Employee(3, "Ching", 36500.00);
		Employee e4 = new Employee(4, "David", 16500.00);
		Employee e5 = new Employee(5, "Cathy", 25500.00);

		List<Employee> list = Arrays.asList(e1, e2, e3, e4, e5);

		Optional<Employee> max = list.stream()
								.collect(Collectors.maxBy(Comparator.comparing(e -> e.salary)));

		System.out.println("Max Salary :: " + max.get().salary);

		Optional<Employee> min = list.stream()
									.collect(Collectors.minBy(Comparator.comparing(e -> e.salary)));
		
		System.out.println("Min Salary :: " + min.get().salary);
		
		Double avgSalary = list.stream().collect(Collectors.averagingDouble(e -> e.salary));
		System.out.println(avgSalary);
	}
}

class Employee {
	int id;
	String name;
	double salary;

	public Employee(int id, String name, double salary) {
		this.id = id;
		this.name = name;
		this.salary = salary;
	}
}

====================
Group By using Stream
====================

-> Group By is used categorize the data / Grouping the data

-> When we use groupingBy ( ) function with stream they it will group the data as Key-Value(s) pair and it will return Map object

-> In below example employees will be grouped based on Country name.

package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class FirstDemo {

	public static void main(String[] args) {

		Employee e1 = new Employee(1, "Robert", 26500.00, "USA");
		Employee e2 = new Employee(2, "Abraham", 46500.00, "INDIA");
		Employee e3 = new Employee(3, "Ching", 36500.00, "CHINA");
		Employee e4 = new Employee(4, "David", 16500.00, "INDIA");
		Employee e5 = new Employee(5, "Cathy", 25500.00, "USA") ;

		List<Employee> list = Arrays.asList(e1, e2, e3, e4, e5);
		
		Map<String, List<Employee>> data = list.stream()
			.collect(Collectors.groupingBy(e -> e.country));
		
		System.out.println(data);
	}
}

class Employee {
	int id;
	String name;
	double salary;
	String country;

	public Employee(int id, String name, double salary, String country) {
		this.id = id;
		this.name = name;
		this.salary = salary;
		this.country = country;
	}
}


Streams(Sequential):
===================

-> Processes elements sequentially, one after another, on a single thread.
-> This is the default behavior when creating a stream.
-> Order is preserved 
-> Good for Small and ordered data

Parallel Streams:
=================

-> A parallel stream divides a stream's elements into multiple parts and processes them concurrently using multiple threads
-> There is no guarantee of the order of execution   
-> Paralell Streams introduced to improve performance of the program.
-> Best for large data sets


package in.ashokit.streams;

import java.util.stream.Stream;

public class ParallelDemo {

	public static void main(String[] args) {

		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

		System.out.println("Sequential Stream Output:");
		
		numbers.stream().map(n -> n * 2).forEach(System.out::println);
		//2,4,6,8,10,12
		
		System.out.println("Parllel Stream Output:");
		numbers.parallelStream().map(n -> n * 2).forEach(System.out::println);
		//8,12,10,2,4,6
	}
}


==============
Java Spliterator
==============

-> Like Iterator and ListIterator, Spliterator is one of the Java Iterator

-> Spliterator introduced in java 1.8v

-> Spliterator is an interface in collections api

-> Spliterator supports both sequential & paralell programming

-> Spliterator we can use to traverse both Collections & Streams

-> Spliterator can't be used with Map implementation classes


package in.ashokit.streams;

import java.util.Arrays;
import java.util.List;
import java.util.Spliterator;

public class ParallelDemo {

	public static void main(String[] args) {

		List<String> names = Arrays.asList("sachin", "sehwag", "dhoni");
		
		Spliterator<String> spliterator = names.stream().spliterator();
		
		spliterator.forEachRemaining(n -> System.out.println(n));
	}
}




=============
Stream Reduce
=============

package demo;

import java.util.Arrays;

public class Sum {

	public static void main(String[] args) {

		int[] nums = { 1, 2, 3, 4, 5 };
		
		/*int sum = 0;
		for(int i : nums) {
			sum = sum + i;
		}
		System.out.println(sum);*/
		
		int reduce = Arrays.stream(nums).reduce(0, (a,b) -> a+b);
		System.out.println(reduce);

	}
}



======================
Nashorn Engine in Java 1.8
======================

-> Nashorn is a Java Script Engine which is used to execute Java Script code using JVM

-> Create a javascript file like below (filename : one.js)

--------------------- one.js --------------------------

var hello = function(){	
	print("Welcome to JavaScript");
}

hello();

------------------------------------------------------

-> Open command prompt and execute below command

	syntax :  jjs one.js


-> We can execute above Java Script file using Java program like below


import java.io.*;

import javax.script.*;

public class Demo {

	public static void main(String... args) throws Exception {

		ScriptEngine se = new ScriptEngineManager().getEngineByName("Nashorn");

		se.eval(new FileReader("one.js"));
	}
}

==========================
I/O Streams Changes in Java 8
==========================

Task : Write a java program to read a file data and print it on the console


-> To read file data we can use FileReader & BufferedReader classes

			
			FileReader ----> It will read the data character by character (slow performance)

			BufferedReader ---> It will read the data line by line

			Files.lines(Path path) ---> It will read all lines at a time and returns as a Stream	


package demo;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class ReadFileData {

	public static void main(String[] args) throws Exception {

		/*FileReader fr = new FileReader(new File("info.txt"));

		BufferedReader br = new BufferedReader(fr);

		String line = br.readLine();

		while (line != null) {
			System.out.println(line);
			line = br.readLine();
		}
		br.close();*/
		
		String filename = "info.txt";
		
		try (Stream<String> stream = Files.lines(Paths.get(filename))){
			
			stream.forEach(line -> System.out.println(line));
			
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
}




=======================
Java 8 Base64 Changes
=======================

-> Base64 is  a predefined class available in java.util package

-> Base64 class providing methods to perform encoding and decoding 


		Encoder encoder = Base64.getEncoder();

		// converting String to byte[] and passing as input for encode( ) method
		byte[] encode = encoder.encode(pwd.getBytes());

		// Converting byte[] to String
		String encodedPwd = new String(encode);

		System.out.println(encodedPwd);
		
		Decoder decoder = Base64.getDecoder();
		
		byte[ ] decode = decoder.decode(encodedPwd);
		String decodedPwd = new String(decode);
		System.out.println(decodedPwd);








Features of Java 8

1)Default and Static methods
2)Functional Interface
3)Lamda Expressions
4)Date Time API
5)Stream API



1)What are Functional Interface in java

A) ->Functional Interface has only one absract method and it can have multiple
   deafault and satatic methods
   
   ->May or may not Annotated with @FunctionalInterface
   
   ->implemented by using lamda
   
   ->Runnable,Callable,Comparator,Predicte,Consumer,Function etc..
   
   
   
2) What are lamda expessions in java

A) ->It is an anonymous funcion and it is correspondences to an interface.
   ->it helps to implement functional programming.
   ->we can define as a method with out name,access specifier and return type
   ->make the code writing simple,easy and short
   
   
3) Use of default method

A) ->helps to add new Functionality to existing interface in application.
   ->Default methods provides backward compatibility.
   ->Backward compatibility is adding new features without breaking the old code
   ->implicitly public.
   

4) what will happen if 2 inerfaces having same default methods and class implement it

A) compilation problem will occure and the solution is we have to override


5) what are static methods used for

A) ->Interface will allow us to write Static methods,so we no need to write
    utility methods by creating a class.
   ->used for provide a common functionality for all the implementation classes.
   ->static method can call by using interface name only.


6) what are streams

A) ->Stream is an interface introduced in Java8 under package called java.util.stream
   and it will reperest sequence of elements and supports parlell and aggregation process.
   
   ->Using streams we can perform operations on Collection ,arrays and iterators.
   
   ->Streams don't store their elements.
   
   -> streams are immutable
   
7) How to create a Stream of Array?

A) By using Stream.of() method or Arrays.of() method
   
   String [] names = {"Ravi","Shankar","Derangula","Salaar"};
   
     Stream.of(names).forEach(p->System.out.println(p));
	 Arrays.Stream(names).forEach(p->System.out.println(p));
	 
8) What are Intermidiate and Terminal Operations

A) Intermediate Operations:
   =======================
   ->They are used to transform or filter the elements of the 
   original Stream by taking input as stream.
   
   ->Since this Operations are lazy it will processs unitil 
     terminal operations called.
	 
	
    map()             sorted()           
    flatMap()         peek()
    distinct()        limit()
	filter()          skip()
    
   
   
   
   Terminal Operations:
   =======================
   ->Terminal operations are used to consume 
    the Stream and produce a result.such as a value, or collection
   
   ->this are early operation
	
   ->forEach(),Colllect,count
   
   
  
9) Diffrences b/w map and flatmap()

Map:
===
-> map is used for transforming the elements same type or another type
-> map is method which takes Function as a parameter
-> Function is the functional interface it takes input of one type and coverts as a output
  same type or diffrent type.
-> Suppose if pass string as parameter then we can converet into upper case or can find the length.



flatMap 
=======
->It is used to flatten list of streams into single stream
-> used when we dealing with nested collections

	 
	 
	 
10)What happens if you try to use a stream after terminal operations

 ->throws Illegal exception saying that it will Stream has already been operated 


findFirst:(return optional)
=========
->The findFirst() method return the first element in a Stream. 
->guarantees order but might be slow in execution


findAny():
=========
->returns any element,especially used for parllel streams
->does not guarantees order and it is very fast in parallel strerams
   
   
   
12)what is diffrences b/w skip and limit method

skip(): skip the first n elements and return the reast stream

limit(): return the first n elements from stream



13)What is optional in java 8 and why it used 

->Optional class is used to avoid null pointer exception.
->In project there is no gaurantee that every programmer will implement null checks. 
  If any body forgot to implement null check then program will throw NullPointerException


14)foreach and foreach ordered

->forEach() method in parell streams does not give the order
->foreachOrdered() method maintains the orginal order even in parella streams

List<Integer> asList = Arrays.asList(2,31,321,12,45,1,54,2);
	
	asList.parallelStream().forEach(p->System.out.print(p));
	
	// out put :14525432112231
	
	System.out.println();
	
	asList.parallelStream().forEachOrdered(p->System.out.print(p));

	// out put :2,31,321,12,45,1,54,2



   
   
15)what happens if you modify a list while iterating over it using stream

->streams do not allow modifications of source while iterating
->it we try to add or remove it will throw concurrent modification exception


16)diffrences b/w orElse and orElseGet()

->The best way to understand the difference between orElse() and orElseGet() is that orElse() 
  will always be executed if the Optional<T> is null or not. 
  But orElseGet() will only be executed when Optional<T> is null.
  
->OrElse method takes a parameter which will be returned if the optional doesnt have value.

->OrElseGet method needs a function(Supplier) which will be executed to return value if the optional doesnt have value.



16)Collectors.toMap() vs Collectors.groupingBy()

Collectors.toMap()
==================
->converts stream into single map
->throws exception if there are duplicate keys


Collectors.groupingBy()
========================
->group elemens by taking key and allow multiple values




================
Method References
=================
->Method reference is represented by using the double colon operator "::".
->Used to create simple lambda expressions by referencing existing methods.
->Method reference is used to refer method of functional interface.

17)What is the difference between PermGenSpace and MetaSpace?

In JDK 8 onwards PermGenSpace is removed. Earlier PermGenSpace is used for storing the metadata. Metadata means storing information about classes like bytecodes, names, and JIT information.


Java classes metadata now stored in a native heap and this space is called MetaSpace. Metaspace grows automatically by default and will be garbage collected.

So the major difference between PermGenSpace and MetaSpace is that PermGenSpace was fixed in size and did not grow automatically, but MetaSpace does not have any size constraints.


Q)18 What do you understand by the term SAM interface? 

Java 8 provided the feature of a functional interface. Since a functional interface can contain only one abstract method, hence, they are called SAM or "Single Abstract Method".


Q)19 What is the difference between Iterator and Spliterator?

->iterator was introduced in JDK 1.2.
->Iterator is used for Collection API 
->Iterator fetch the element in sequential form.

->Spliterator is introduced in JDK 1.8(Both are Interfaces only)     
->while Spliterator is used for Stream API as well as  Collection API
->Spliterator fetch the element in sequential and parellel and High performence
  compared to Iterator









